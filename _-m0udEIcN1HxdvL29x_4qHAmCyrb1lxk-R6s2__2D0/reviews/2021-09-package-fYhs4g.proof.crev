----- BEGIN CREV PROOF -----
kind: package review
version: -1
date: "2021-09-12T18:31:19.335923631+09:00"
from:
  id-type: crev
  id: _-m0udEIcN1HxdvL29x_4qHAmCyrb1lxk-R6s2__2D0
package:
  source: "https://crates.io"
  name: cryo
  version: 0.2.3
  revision: 616eaeb9a950e31671d03f0f92709bd3f731f405
  digest: 6qCEm6dCjKOyK9Cc3_d6tNS7k_xy1z_VO1eXsSZg5_w
review:
  thoroughness: high
  understanding: high
  rating: negative
advisories:
  - ids:
      - "https://github.com/yvt/cryo/commit/0f60cd9f5459a6c4c0ceb1923d595ef7e2e127f2"
    severity: medium
    range: minor
    comment: "This release replaces `{Cryo, CryoMut}::new` with `unsafe fn`s as they\nwere found to be unsound. This issue is explained in this package's latest\nversion's [API documentation][1].\n\n[1]: https://docs.rs/cryo/0.2.6/cryo/struct.Cryo.html#method.new"
comment: |-
  This is a self-review. 
  
  While this release fixes a soundness issue, there is another soundness issue
  remaining regarding the `cryo!` macro (fixed in version 0.2.4), hence the
  negative rating. Please refer to the latest version's API documentation for
  [a description][1] of the issue.
  
  [1]: https://docs.rs/cryo/0.2.6/cryo/macro.cryo.html#safety
----- SIGN CREV PROOF -----
xT4m5wPLfFevXiri9wPSh4cGW-Gab_Fp_pAHZLOjjwMJTOnZmDsvI5qUlrY6MYHfKUBHGVC4xjow-8NBh9eACg
----- END CREV PROOF -----

----- BEGIN CREV PROOF -----
kind: package review
version: -1
date: "2021-09-12T19:05:54.047570870+09:00"
from:
  id-type: crev
  id: _-m0udEIcN1HxdvL29x_4qHAmCyrb1lxk-R6s2__2D0
package:
  source: "https://crates.io"
  name: cryo
  version: 0.2.4
  revision: ddeccfba93bd2330d12699b842a8f47a78a50e13
  digest: ixrb3aR4vmCN25TYgTC_WhykHaJepn2NZwOpLIQKzLM
review:
  thoroughness: high
  understanding: high
  rating: neutral
advisories:
  - ids:
      - "https://github.com/yvt/cryo/commit/3cd529a8665063e98961e08b4df25d398d9bd4b5"
    severity: medium
    range: minor
    comment: "This release fixes a soundness issue with the `cryo!` macro where, when\nused inside `async fn`, it allows safe code to circumvent the\ncompile-time lifetime checking, rendering the code vulnerable to a\nuse-after-free bug. The description about this issue can be found in the\nlatest version's [API documentation][1]. `cryo!` is still there but now\nmarked as deprecated to warn users about this issue.\n\n[1]: https://docs.rs/cryo/0.2.6/cryo/macro.cryo.html#safety"
comment: |-
  This is a self-review.
  
  After two soundness issues being fixed, this package should be more solid
  than ever and devoid of any serious bugs. Nevertheless, I'm giving a neutral
  rating to provide warning about any remaining, potentially unsound usage of
  the now-deprecated `cryo!`.
----- SIGN CREV PROOF -----
lfi1WUxofPMC3Jgd2rkHliEvDoGaYDvsUaGATm5OxTDHi1CWnSrrSUwayFQMXVGhk5ZOgS73N4ffs7J3oFoSDA
----- END CREV PROOF -----

----- BEGIN CREV PROOF -----
kind: package review
version: -1
date: "2021-09-12T20:01:39.552214874+09:00"
from:
  id-type: crev
  id: _-m0udEIcN1HxdvL29x_4qHAmCyrb1lxk-R6s2__2D0
  url: "https://github.com/yvt/crev-proofs"
package:
  source: "https://crates.io"
  name: stable_deref_trait
  version: 1.2.0
  revision: 66f9d8a15b7209c45f58edee6c1b6bb497b7bd31
  digest: nSByNb8Gm3mLQItFfk2LhBUfpeusoqcHbHxolGl6QoM
review:
  thoroughness: medium
  understanding: high
  rating: positive
comment: |-
  The sole purpose of this crate is define the two traits `StableDeref` and
  `CloneStableDeref` and provide their implementations on built-in and standard
  library types. These marker traits define requirements on the stability of
  the `Deref` results of the ascribed type.
  
  The trait requirements are defined clearly. Although (to my knowledge) some
  of the standard library types marked with these traits don't explicitly or
  indirectly say in their documentation that the requirements specified by
  these traits are guaranteed to be upheld for these types, it's correct for
  the current version of Rust and any possible sane reimplementation of the
  standard library, and one can reasonably expect that it will remain so in
  future versions.
----- SIGN CREV PROOF -----
gWzzaLP9IOoi6PImlaklvTM0k2OU5hOASfjvpRjms8sEUdAGescSZkvQq1Z38uyQBx2qzieKqk_XbKCJehYcAg
----- END CREV PROOF -----

----- BEGIN CREV PROOF -----
kind: package review
version: -1
date: "2021-09-12T20:49:30.199229014+09:00"
from:
  id-type: crev
  id: _-m0udEIcN1HxdvL29x_4qHAmCyrb1lxk-R6s2__2D0
  url: "https://github.com/yvt/crev-proofs"
package:
  source: "https://crates.io"
  name: memory_units
  version: 0.4.0
  digest: ktE4A0aEGyiKNRxUUdd8CCmUnkC_VC8HOwuXBomYNZE
review:
  thoroughness: medium
  understanding: high
  rating: neutral
comment: |-
  This crate is sound - It includes no `unsafe` blocks and performs no
  unexpected access to external environments. It has no build scripts.
  
  The `round_up_to` method provided by this crate does not perform overflow
  checks nor describe its overflow behaviors. If the downstream crates don't
  handle this condition correctly, it might lead to a vulnerability similar to
  [BadAlloc][1].
  
  This crate also assumes the compilation target's page size is 4096 bytes,
  which is not universal as exemplified by Apple Arm platforms.
  
  [1]: https://msrc-blog.microsoft.com/2021/04/29/badalloc-memory-allocation-vulnerabilities-could-affect-wide-range-of-iot-and-ot-devices-in-industrial-medical-and-enterprise-networks/
----- SIGN CREV PROOF -----
Rmi9P4beQyCVeQb6yGIpVgf1jXlObpdaWpMed0qeCEmHkRG17PHH2QXp29NZEe1uJcg6aVhcPEK-AssMHjjjAQ
----- END CREV PROOF -----

----- BEGIN CREV PROOF -----
kind: package review
version: -1
date: "2021-09-18T12:01:54.372173567+09:00"
from:
  id-type: crev
  id: _-m0udEIcN1HxdvL29x_4qHAmCyrb1lxk-R6s2__2D0
  url: "https://github.com/yvt/crev-proofs"
package:
  source: "https://crates.io"
  name: atomic-option
  version: 0.1.2
  digest: NGWWOLFwqTtESjF8DNRBjS_1jZ7wIdV7pOr5x4cqV0I
review:
  thoroughness: high
  understanding: medium
  rating: negative
issues:
  - id: RUSTSEC-2020-0113
    severity: high
    comment: "Incorrect `Sync` bounds"
  - id: "https://github.com/reem/rust-atomic-option/issues/3"
    severity: high
    comment: Underconstrained memory ordering
flags:
  unmaintained: true
comment: |-
  This crate provides an atomic cell type named `AtomicOption` to store
  `Box<T>`.
  
  This crate is severely flawed and unsound but not malicious, hence the
  negative rating.
  
  Marking as unmaintained because of several serious issues being left unfixed
  for at least a year.
  
  # Major issues
  
  ## Underconstrained memory ordering
  
  `AtomicOption`'s methods allow the caller to specify memory orderings weaker
  than what would be safe. Consider the following two processes:
  
  ```
     // Process 1:
  1  let mut boxed = Box::new(1);
  2  *boxed = 2;
  3  atom_opt.swap(boxed, Ordering::Relaxed);
  
                           // Process 2:
                        4  let boxed = atom_opt.take(Ordering::Relaxed).unwrap();
                        5  dbg!(*boxed);
  ```
  
  Process 1 performs two writes on `*boxed` at line numbers 1 and 2. Supposing
  Process 2 observes the `boxed` sent by Process 1 at line number 4, it performs
  one read on `*boxed` at line number 5. Since the writes and read are not
  ordered properly, the read [creates][5] an `undef` value.
  
  There's [a three year old GitHub issue][3] reporting this problem.
  
  ## Pointer-to-integer transmutation
  
  This crate uses pointer-to-integer transmutation, which has unresolved issues
  regarding pointer provenance[1]. This could be safely avoided by replacing
  the internally-used `AtomicUsize` with `AtomicPtr`.
  
  ## Incorrect `Sync` bounds
  
  `AtomicOption` unconditionally implements `Sync`, which allows `T: !Send` to
  be sent to another thread through `&AtomicOption`. There's [a RustSec
  advisory][2] regarding this issue.
  
  # Minor issues
  
  The documentation of the `unsafe fn` `AtomicOption::from_raw` doesn't describe
  the safe usage.
  
  The use of `SeqCst` in `AtomicOption::drop` [suggests][4] the author's lack of
  understanding in atomics and memory ordering.
  
  # Good things
  
  The crate is quite small as it contains only about 200 lines (including
  comments) of Rust code.
  
  [1]: https://github.com/rust-lang/unsafe-code-guidelines/issues/286
  [2]: https://rustsec.org/advisories/RUSTSEC-2020-0113.html
  [3]: https://github.com/reem/rust-atomic-option/issues/3
  [4]: https://github.com/rust-lang/nomicon/issues/166
  [5]: https://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations
----- SIGN CREV PROOF -----
vQx1UTBqjPlBh1LLPF1Ra3Tjayde68pTDxZ-qdc1CDP2av2siDiWlCH8fPawDN5OXsJ7p4MMnwECqNfwL46mBQ
----- END CREV PROOF -----

----- BEGIN CREV PROOF -----
kind: package review
version: -1
date: "2021-09-18T22:06:40.532021599+09:00"
from:
  id-type: crev
  id: _-m0udEIcN1HxdvL29x_4qHAmCyrb1lxk-R6s2__2D0
  url: "https://github.com/yvt/crev-proofs"
package:
  source: "https://crates.io"
  name: atomic_refcell
  version: 0.1.7
  revision: 5a1fe43c00e65a62ef88f86679eb7ff4b9334c32
  digest: wD6S0aAbFNUNLkkbhflR3QT62Bt7dMWjCmiu6P-BxAo
review:
  thoroughness: medium
  understanding: medium
  rating: neutral
alternatives:
  - source: "https://crates.io"
    name: spin
comment: |-
  Basically `std::sync::RwLock` with panicking instead of blocking.
  
  `AtomicRefCell` uses atomic operations to manipulate the variable containing
  the borrow state. Overall, the usage of atomic operations looks correct.
  
  # Minor issue
  
  The bounds for `AtomicRefCell<T>: Send` are [unnecessarily restrictive][1].
  
  `AtomicRefCell` aborts the program if a large number of immutable borrow
  attempts are made while it's mutably borrowed. While a code comment claims
  this is "very unlikely to happen in a real program", this can cause a problem
  in a program that uses `AtomicRefCell` in a way unintended by
  `atomic_refcell`'s authors and runs on a 32-bit target architecture.
  [`spin`][2]`::RwLock` doesn't have this problem.
  
  [1]: https://github.com/bholley/atomic_refcell/issues/13
  [2]: https://crates.io/crates/spin
----- SIGN CREV PROOF -----
zXxqKAsYnmM1Iy2zOgvcLVY5Ttrzlb5AGFKHasz3vlzTci87a8OfDyJbZiZUZhOwxihMIFR43pumQvz4PnigAQ
----- END CREV PROOF -----

----- BEGIN CREV PROOF -----
kind: package review
version: -1
date: "2021-09-18T23:28:14.421201329+09:00"
from:
  id-type: crev
  id: _-m0udEIcN1HxdvL29x_4qHAmCyrb1lxk-R6s2__2D0
  url: "https://github.com/yvt/crev-proofs"
package:
  source: "https://crates.io"
  name: take_mut
  version: 0.2.2
  digest: JUynnuTS3tglX7Sb0vHUqHkX1PhGTrTtiMN4txyDA_w
review:
  thoroughness: medium
  understanding: medium
  rating: negative
issues:
  - id: "https://github.com/Sgeo/take_mut/pull/10"
    severity: medium
    comment: Recovery closure leakage
flags:
  unmaintained: true
alternatives:
  - source: "https://crates.io"
    name: replace_with
comment: |-
  While the idea of making a variable temporarily uninitialized may sound scary,
  this crate takes necessary precaution to make this sound.
  
  Unfortunately, this crate has [a resource leak issue][1] that has been left
  open for two years, hence the negative rating.
  
  This crate looks unmaintained as the last commit is from 2018.
  
  [1]: https://github.com/Sgeo/take_mut/pull/10
----- SIGN CREV PROOF -----
Yi8-sPmqzMi3-SgDqeF5-YPb4Hc9ovkK8y3UxWP5m6sbaQQUD1Y9oxT1ynL-z3zbpe9BsavxWp9VPOZZ3zAhDw
----- END CREV PROOF -----

