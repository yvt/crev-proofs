----- BEGIN CREV PROOF -----
kind: package review
version: -1
date: "2021-09-12T18:31:19.335923631+09:00"
from:
  id-type: crev
  id: _-m0udEIcN1HxdvL29x_4qHAmCyrb1lxk-R6s2__2D0
package:
  source: "https://crates.io"
  name: cryo
  version: 0.2.3
  revision: 616eaeb9a950e31671d03f0f92709bd3f731f405
  digest: 6qCEm6dCjKOyK9Cc3_d6tNS7k_xy1z_VO1eXsSZg5_w
review:
  thoroughness: high
  understanding: high
  rating: negative
advisories:
  - ids:
      - "https://github.com/yvt/cryo/commit/0f60cd9f5459a6c4c0ceb1923d595ef7e2e127f2"
    severity: medium
    range: minor
    comment: "This release replaces `{Cryo, CryoMut}::new` with `unsafe fn`s as they\nwere found to be unsound. This issue is explained in this package's latest\nversion's [API documentation][1].\n\n[1]: https://docs.rs/cryo/0.2.6/cryo/struct.Cryo.html#method.new"
comment: |-
  This is a self-review. 
  
  While this release fixes a soundness issue, there is another soundness issue
  remaining regarding the `cryo!` macro (fixed in version 0.2.4), hence the
  negative rating. Please refer to the latest version's API documentation for
  [a description][1] of the issue.
  
  [1]: https://docs.rs/cryo/0.2.6/cryo/macro.cryo.html#safety
----- SIGN CREV PROOF -----
xT4m5wPLfFevXiri9wPSh4cGW-Gab_Fp_pAHZLOjjwMJTOnZmDsvI5qUlrY6MYHfKUBHGVC4xjow-8NBh9eACg
----- END CREV PROOF -----

----- BEGIN CREV PROOF -----
kind: package review
version: -1
date: "2021-09-12T19:05:54.047570870+09:00"
from:
  id-type: crev
  id: _-m0udEIcN1HxdvL29x_4qHAmCyrb1lxk-R6s2__2D0
package:
  source: "https://crates.io"
  name: cryo
  version: 0.2.4
  revision: ddeccfba93bd2330d12699b842a8f47a78a50e13
  digest: ixrb3aR4vmCN25TYgTC_WhykHaJepn2NZwOpLIQKzLM
review:
  thoroughness: high
  understanding: high
  rating: neutral
advisories:
  - ids:
      - "https://github.com/yvt/cryo/commit/3cd529a8665063e98961e08b4df25d398d9bd4b5"
    severity: medium
    range: minor
    comment: "This release fixes a soundness issue with the `cryo!` macro where, when\nused inside `async fn`, it allows safe code to circumvent the\ncompile-time lifetime checking, rendering the code vulnerable to a\nuse-after-free bug. The description about this issue can be found in the\nlatest version's [API documentation][1]. `cryo!` is still there but now\nmarked as deprecated to warn users about this issue.\n\n[1]: https://docs.rs/cryo/0.2.6/cryo/macro.cryo.html#safety"
comment: |-
  This is a self-review.
  
  After two soundness issues being fixed, this package should be more solid
  than ever and devoid of any serious bugs. Nevertheless, I'm giving a neutral
  rating to provide warning about any remaining, potentially unsound usage of
  the now-deprecated `cryo!`.
----- SIGN CREV PROOF -----
lfi1WUxofPMC3Jgd2rkHliEvDoGaYDvsUaGATm5OxTDHi1CWnSrrSUwayFQMXVGhk5ZOgS73N4ffs7J3oFoSDA
----- END CREV PROOF -----

----- BEGIN CREV PROOF -----
kind: package review
version: -1
date: "2021-09-12T20:01:39.552214874+09:00"
from:
  id-type: crev
  id: _-m0udEIcN1HxdvL29x_4qHAmCyrb1lxk-R6s2__2D0
  url: "https://github.com/yvt/crev-proofs"
package:
  source: "https://crates.io"
  name: stable_deref_trait
  version: 1.2.0
  revision: 66f9d8a15b7209c45f58edee6c1b6bb497b7bd31
  digest: nSByNb8Gm3mLQItFfk2LhBUfpeusoqcHbHxolGl6QoM
review:
  thoroughness: medium
  understanding: high
  rating: positive
comment: |-
  The sole purpose of this crate is define the two traits `StableDeref` and
  `CloneStableDeref` and provide their implementations on built-in and standard
  library types. These marker traits define requirements on the stability of
  the `Deref` results of the ascribed type.
  
  The trait requirements are defined clearly. Although (to my knowledge) some
  of the standard library types marked with these traits don't explicitly or
  indirectly say in their documentation that the requirements specified by
  these traits are guaranteed to be upheld for these types, it's correct for
  the current version of Rust and any possible sane reimplementation of the
  standard library, and one can reasonably expect that it will remain so in
  future versions.
----- SIGN CREV PROOF -----
gWzzaLP9IOoi6PImlaklvTM0k2OU5hOASfjvpRjms8sEUdAGescSZkvQq1Z38uyQBx2qzieKqk_XbKCJehYcAg
----- END CREV PROOF -----

----- BEGIN CREV PROOF -----
kind: package review
version: -1
date: "2021-09-12T20:49:30.199229014+09:00"
from:
  id-type: crev
  id: _-m0udEIcN1HxdvL29x_4qHAmCyrb1lxk-R6s2__2D0
  url: "https://github.com/yvt/crev-proofs"
package:
  source: "https://crates.io"
  name: memory_units
  version: 0.4.0
  digest: ktE4A0aEGyiKNRxUUdd8CCmUnkC_VC8HOwuXBomYNZE
review:
  thoroughness: medium
  understanding: high
  rating: neutral
comment: |-
  This crate is sound - It includes no `unsafe` blocks and performs no
  unexpected access to external environments. It has no build scripts.
  
  The `round_up_to` method provided by this crate does not perform overflow
  checks nor describe its overflow behaviors. If the downstream crates don't
  handle this condition correctly, it might lead to a vulnerability similar to
  [BadAlloc][1].
  
  This crate also assumes the compilation target's page size is 4096 bytes,
  which is not universal as exemplified by Apple Arm platforms.
  
  [1]: https://msrc-blog.microsoft.com/2021/04/29/badalloc-memory-allocation-vulnerabilities-could-affect-wide-range-of-iot-and-ot-devices-in-industrial-medical-and-enterprise-networks/
----- SIGN CREV PROOF -----
Rmi9P4beQyCVeQb6yGIpVgf1jXlObpdaWpMed0qeCEmHkRG17PHH2QXp29NZEe1uJcg6aVhcPEK-AssMHjjjAQ
----- END CREV PROOF -----

----- BEGIN CREV PROOF -----
kind: package review
version: -1
date: "2021-09-18T12:01:54.372173567+09:00"
from:
  id-type: crev
  id: _-m0udEIcN1HxdvL29x_4qHAmCyrb1lxk-R6s2__2D0
  url: "https://github.com/yvt/crev-proofs"
package:
  source: "https://crates.io"
  name: atomic-option
  version: 0.1.2
  digest: NGWWOLFwqTtESjF8DNRBjS_1jZ7wIdV7pOr5x4cqV0I
review:
  thoroughness: high
  understanding: medium
  rating: negative
issues:
  - id: RUSTSEC-2020-0113
    severity: high
    comment: "Incorrect `Sync` bounds"
  - id: "https://github.com/reem/rust-atomic-option/issues/3"
    severity: high
    comment: Underconstrained memory ordering
flags:
  unmaintained: true
comment: |-
  This crate provides an atomic cell type named `AtomicOption` to store
  `Box<T>`.
  
  This crate is severely flawed and unsound but not malicious, hence the
  negative rating.
  
  Marking as unmaintained because of several serious issues being left unfixed
  for at least a year.
  
  # Major issues
  
  ## Underconstrained memory ordering
  
  `AtomicOption`'s methods allow the caller to specify memory orderings weaker
  than what would be safe. Consider the following two processes:
  
  ```
     // Process 1:
  1  let mut boxed = Box::new(1);
  2  *boxed = 2;
  3  atom_opt.swap(boxed, Ordering::Relaxed);
  
                           // Process 2:
                        4  let boxed = atom_opt.take(Ordering::Relaxed).unwrap();
                        5  dbg!(*boxed);
  ```
  
  Process 1 performs two writes on `*boxed` at line numbers 1 and 2. Supposing
  Process 2 observes the `boxed` sent by Process 1 at line number 4, it performs
  one read on `*boxed` at line number 5. Since the writes and read are not
  ordered properly, the read [creates][5] an `undef` value.
  
  There's [a three year old GitHub issue][3] reporting this problem.
  
  ## Pointer-to-integer transmutation
  
  This crate uses pointer-to-integer transmutation, which has unresolved issues
  regarding pointer provenance[1]. This could be safely avoided by replacing
  the internally-used `AtomicUsize` with `AtomicPtr`.
  
  ## Incorrect `Sync` bounds
  
  `AtomicOption` unconditionally implements `Sync`, which allows `T: !Send` to
  be sent to another thread through `&AtomicOption`. There's [a RustSec
  advisory][2] regarding this issue.
  
  # Minor issues
  
  The documentation of the `unsafe fn` `AtomicOption::from_raw` doesn't describe
  the safe usage.
  
  The use of `SeqCst` in `AtomicOption::drop` [suggests][4] the author's lack of
  understanding in atomics and memory ordering.
  
  # Good things
  
  The crate is quite small as it contains only about 200 lines (including
  comments) of Rust code.
  
  [1]: https://github.com/rust-lang/unsafe-code-guidelines/issues/286
  [2]: https://rustsec.org/advisories/RUSTSEC-2020-0113.html
  [3]: https://github.com/reem/rust-atomic-option/issues/3
  [4]: https://github.com/rust-lang/nomicon/issues/166
  [5]: https://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations
----- SIGN CREV PROOF -----
vQx1UTBqjPlBh1LLPF1Ra3Tjayde68pTDxZ-qdc1CDP2av2siDiWlCH8fPawDN5OXsJ7p4MMnwECqNfwL46mBQ
----- END CREV PROOF -----

----- BEGIN CREV PROOF -----
kind: package review
version: -1
date: "2021-09-18T22:06:40.532021599+09:00"
from:
  id-type: crev
  id: _-m0udEIcN1HxdvL29x_4qHAmCyrb1lxk-R6s2__2D0
  url: "https://github.com/yvt/crev-proofs"
package:
  source: "https://crates.io"
  name: atomic_refcell
  version: 0.1.7
  revision: 5a1fe43c00e65a62ef88f86679eb7ff4b9334c32
  digest: wD6S0aAbFNUNLkkbhflR3QT62Bt7dMWjCmiu6P-BxAo
review:
  thoroughness: medium
  understanding: medium
  rating: neutral
alternatives:
  - source: "https://crates.io"
    name: spin
comment: |-
  Basically `std::sync::RwLock` with panicking instead of blocking.
  
  `AtomicRefCell` uses atomic operations to manipulate the variable containing
  the borrow state. Overall, the usage of atomic operations looks correct.
  
  # Minor issue
  
  The bounds for `AtomicRefCell<T>: Send` are [unnecessarily restrictive][1].
  
  `AtomicRefCell` aborts the program if a large number of immutable borrow
  attempts are made while it's mutably borrowed. While a code comment claims
  this is "very unlikely to happen in a real program", this can cause a problem
  in a program that uses `AtomicRefCell` in a way unintended by
  `atomic_refcell`'s authors and runs on a 32-bit target architecture.
  [`spin`][2]`::RwLock` doesn't have this problem.
  
  [1]: https://github.com/bholley/atomic_refcell/issues/13
  [2]: https://crates.io/crates/spin
----- SIGN CREV PROOF -----
zXxqKAsYnmM1Iy2zOgvcLVY5Ttrzlb5AGFKHasz3vlzTci87a8OfDyJbZiZUZhOwxihMIFR43pumQvz4PnigAQ
----- END CREV PROOF -----

----- BEGIN CREV PROOF -----
kind: package review
version: -1
date: "2021-09-18T23:28:14.421201329+09:00"
from:
  id-type: crev
  id: _-m0udEIcN1HxdvL29x_4qHAmCyrb1lxk-R6s2__2D0
  url: "https://github.com/yvt/crev-proofs"
package:
  source: "https://crates.io"
  name: take_mut
  version: 0.2.2
  digest: JUynnuTS3tglX7Sb0vHUqHkX1PhGTrTtiMN4txyDA_w
review:
  thoroughness: medium
  understanding: medium
  rating: negative
issues:
  - id: "https://github.com/Sgeo/take_mut/pull/10"
    severity: medium
    comment: Recovery closure leakage
flags:
  unmaintained: true
alternatives:
  - source: "https://crates.io"
    name: replace_with
comment: |-
  While the idea of making a variable temporarily uninitialized may sound scary,
  this crate takes necessary precaution to make this sound.
  
  Unfortunately, this crate has [a resource leak issue][1] that has been left
  open for two years, hence the negative rating.
  
  This crate looks unmaintained as the last commit is from 2018.
  
  [1]: https://github.com/Sgeo/take_mut/pull/10
----- SIGN CREV PROOF -----
Yi8-sPmqzMi3-SgDqeF5-YPb4Hc9ovkK8y3UxWP5m6sbaQQUD1Y9oxT1ynL-z3zbpe9BsavxWp9VPOZZ3zAhDw
----- END CREV PROOF -----

----- BEGIN CREV PROOF -----
kind: package review
version: -1
date: "2021-09-20T00:44:24.666158401+09:00"
from:
  id-type: crev
  id: _-m0udEIcN1HxdvL29x_4qHAmCyrb1lxk-R6s2__2D0
  url: "https://github.com/yvt/crev-proofs"
package:
  source: "https://crates.io"
  name: atomic-ref2
  version: 0.2.1
  digest: nO-r3XcgeXoQkbDbUWYoZJa5tpMLP4QWeIgaq4HQH8Y
review:
  thoroughness: high
  understanding: medium
  rating: negative
issues:
  - id: "https://github.com/mehcode/atomic-ref2-rs/issues/1"
    severity: high
    comment: "`Atomic[Option]Ref<T>` implements `Send + Sync` unconditionally"
flags:
  unmaintained: true
alternatives:
  - source: "https://crates.io"
    name: crossbeam
  - source: "https://crates.io"
    name: atom
comment: |-
  This crate provides an atomic cell type to store `Option<Arc<T>>`.
  
  ## Major issues
  
  The bounds for `Atomic[Option]Ref<T>: Send + Sync` are unconstrained, which
  allows thread-unsafe objects to be sent between threads, potentially leading
  to data race.
  
  ## Minor issues
  
  The atomic operations in this crate are riddled with seemingly unnecessary
  `Ordering::SeqCst`, which is [considered][1] by some (including myself) to be
  a code smell.
  
  While most atomic operations in this crate are `SeqCst`, there are a few
  places where `Relaxed` is used. Although stress-testing did not reveal any
  problems, there's a theoretical soundness issue regarding the usage of
  `Relaxed` as explained in the next section. It's very possible that the
  excessive usage of `SeqCst` is why this issue doesn't seem to surface in
  practice.
  
  ### Theoretical issue with the `Relaxed` memory ordering
  
  *Disclaimer: I'm not expert in the C++20 memory model, and therefore the
  assessment presented here might be incorrect.*
  
  Shown below is a simplified code listing of `AtomicOptionRef`'s each method
  with a syntax loosely inspired by [Promela][2]. Brackets indicate the memory
  orderings for atomic operations (`[SC]` = `SeqCst`, `[]` = `Relaxed`).
  
  ```text
      load(self):
  10      [SC] (self.lock & WRITER_BIT) == 0 -> self.lock += 1
  11      [SC] out = self.ptr
  12      []   out.ref_count += 1
  13      [SC] self.lock -= 1
  14           return out
  
      swap(self, in)
  20      [SC] (self.lock & WRITER_BIT) == 0 -> self.lock |= WRITER_BIT
  21      []   self.lock == WRITER_BIT ->
  22      [SC] (out, self.ptr) = (self.ptr, in)
  23      []   self.lock = 0
  24           return out
  ```
  
  Suppose two threads execute the following sequences (multiple execution
  instances of a single program line are distinguished by alphabetic suffixes):
  
   - T1: 20a, 21a, 22a, 23a, 24a, 20b, 21b, 22b, 23b, 24b
   - T2: 10, 11, 12, 13, 14
  
  Also suppose that T2 observed the write performed by 23b at 10. The question
  is, which `self.ptr` will T2 observe at 11? It would be unsafe to observe the
  `self.ptr` written by 22a because that `self.ptr` is returned to the caller by
  22b, and by the time 12 is executed, it might refer to an already-deallocated
  memory region. For this unsafe case to manifest, the total order `S = [20a,
  22a, 20b, 10, 11, 22b]` on `SeqCst` operations must be valid.
  
  ```text
  
                     ,--------------,
                     |              |
      T1: 20a  21a  22a  23a  24a  20b  21b  22b  23b  24b
           |         |              |         ^    |
           '---------'              |         |    |
                                    |         |    | side-effect observed
                                  S |,-------------'
                                    ||        |
                                    vv        |
      T2:                           10        11
                                    |         |
                                    '---------' S
  
  Transitive reduction of the "(strongly|simply)? happens-before" relationship
  
      T1: 20a -> 21a -> 22a -> 23a -> 24a -> 20b -> 21b -> 22b -> 23b -> 24b
                         |
                         '----------------, SC-SC
                                          |
                                          v
      T2:                          10 -> 11
  
    (Note: 23b doesn't (simply) happens-before 10 because 23b uses the `Relaxed`
           ordering.)
  
  Transitive reduction of the "coherence-ordered" relationship
  
      T1: 20a -> 21a    22a    23a    24a    20b -> 21b    22b    23b    24b
                  |      |     ^ |            ^      |      ^     ^ |
     on self.lock '------|-----' '------------'      '------|-----' |
                         |                                  |       |
                         '----------------+-----------------'       |
                    on self.ptr           |                         |
                                    ,-----|-------------------------'
                                    v     v
      T2:                          10    11
  
  ```
  
  For this total order to be valid, it must be consistent with the "strongly
  happen-before" relationship (C++ N4861 31.4 4) and the "coherence-ordered
  relationship" on every object (C++ N4861 31.4 4.1). It's clear from the above
  diagram that `S` meets this requirement.
  
  Furthermore, for 11 to observe the write by 22a, 22b must not happen-before
  11, which is also met as shown in the above diagram.
  
  Therefore, it's possible for T2 to observe the write by 22a at 11, meaning,
  during this method call, `AtomicOptionRef::load()` can clone `Arc<T>` that has
  been previously returned by `AtomicOptionRef::swap()`, which can cause an
  undefined behavior because it's possible that this `Arc<T>` is dropped by the
  caller, and its control block doesn't exist anymore.
  
  ## Meta Issues
  
  The `homepage` field of the package metadata is incorrect. The correct URL is <https://github.com/mehcode/atomic-ref2-rs>.
  
  [1]: https://github.com/rust-lang/nomicon/issues/166
  [2]: https://spinroot.com/spin/what.html
----- SIGN CREV PROOF -----
4hs8cP4r1pIEfGtsn5YM41xPD-gnmuH0budk6gjT-UA_R_hk9QFfJj_foXI4-woDPU1V7S8UzD4oBkf80tfECA
----- END CREV PROOF -----

----- BEGIN CREV PROOF -----
kind: package review
version: -1
date: "2021-09-20T01:59:13.756728432+09:00"
from:
  id-type: crev
  id: _-m0udEIcN1HxdvL29x_4qHAmCyrb1lxk-R6s2__2D0
  url: "https://github.com/yvt/crev-proofs"
package:
  source: "https://crates.io"
  name: atomic_ref
  version: 0.2.1
  revision: 2e94d6a88ca6b5abb2e1d284e7fce91319f56fc2
  digest: 88O6OmeG8TwWsYfmmEzUg72nTKCPxeNOyZ8-W1J2Fig
review:
  thoroughness: medium
  understanding: medium
  rating: positive
advisories:
  - ids:
      - "https://github.com/mystor/atomic_ref/pull/6"
    severity: high
    comment: "Previous verions of `atomic_ref` have a bug in which `AtomicRef`'s\nmethods accept unsafe memory orderings."
comment: |-
  This crate provides an atomic cell to store `Option<&T>`.
  
  This crate is sound and has no known issues. `AtomicRef` has the correct trait
  bounds for `Sync`/`Send`-ness and employs the minimum memory ordering to
  make sure that, when a reference that was recently written through was stored
  to an `AtomicRef`, whoever loads that reference is guaranteed to observe the
  value written. (This requires acquire/release synchronization for all loads
  and stores on `AtomicRef`. Without it, the reader could observe a stale value,
  causing an undefined behavior. This was recently reported by [#5][1] and fixed
  by [#6][2].)
  
  [1]: https://github.com/mystor/atomic_ref/issues/5
  [2]: https://github.com/mystor/atomic_ref/pull/6
----- SIGN CREV PROOF -----
KpQTnVwFaeBc6-ggeZSzsVSTCadNu-gPa49MyzkvrFJcasDpCyyx9R1AedqYFRJLuXkMABqAib6F15tK0zwvDg
----- END CREV PROOF -----

----- BEGIN CREV PROOF -----
kind: package review
version: -1
date: "2021-09-23T13:00:35.951625951+09:00"
from:
  id-type: crev
  id: _-m0udEIcN1HxdvL29x_4qHAmCyrb1lxk-R6s2__2D0
  url: "https://github.com/yvt/crev-proofs"
package:
  source: "https://crates.io"
  name: metaverse
  version: 0.0.1
  revision: 44f36ffbccbe69e7d3c13d4162755578ac390618
  digest: v_vBzWIY4lRqo0e-9hXawTFCZX4mbWzV3vyaJyF4mz0
review:
  thoroughness: medium
  understanding: medium
  rating: negative
comment: |-
  This crate doesn't seem to do anything useful, and its intent is unclear, but
  probably it's for name-squatting or [making a point][1] about the lack of
  name-squatting policy. The author released a series of crates with similar
  contents:
  
   - <https://crates.io/crates/khipo/0.0.1>
   - <https://crates.io/crates/hakuna/0.0.1>
   - <https://crates.io/crates/matata/0.0.1>
   - <https://crates.io/crates/metaverse/0.0.1>
   - <https://crates.io/crates/loquat/0.0.1>
   - <https://crates.io/crates/gothic/0.0.1>
   - <https://crates.io/crates/lemon/0.0.1>
   - <https://crates.io/crates/cupola/0.0.1>
  
  This crate is harmless.
  
  [1]: https://docs.rs/crate/cupola/0.1.1
----- SIGN CREV PROOF -----
6CHuGTtth8EpTrwbDk8QjkG4ah9ji0VNnKOKQrgEHCrrfgzSeq0xIn1Wh0gDflUu9MV7g1Bpfco5FXMwn_WXAg
----- END CREV PROOF -----

----- BEGIN CREV PROOF -----
kind: package review
version: -1
date: "2021-09-23T13:30:06.452940753+09:00"
from:
  id-type: crev
  id: _-m0udEIcN1HxdvL29x_4qHAmCyrb1lxk-R6s2__2D0
  url: "https://github.com/yvt/crev-proofs"
package:
  source: "https://crates.io"
  name: khipo
  version: 0.0.1
  revision: 4a57b8f556ba5710f5a39f56b88b29067c7fa418
  digest: 7bQt0CbQL08cpIKovjFFbYV-URCAmueUED06OMMVZbs
review:
  thoroughness: medium
  understanding: medium
  rating: negative
comment: |-
  This crate doesn't seem to do anything useful, and its intent is unclear, but
  probably it's for name-squatting or [making a point][1] about the lack of
  name-squatting policy. The author released a series of crates with similar
  contents. See my review on metaverse 0.0.1 for the list.
  
  This crate is harmless.
  
  [1]: https://docs.rs/crate/cupola/0.1.1
----- SIGN CREV PROOF -----
7kFo_H-zQu2J3o2xwS_gr1jSllXSgp-ILA2iQpCrwQAMWllRud6d-9f6KCZBl9yh9W4V4HmahN6yzbpivjNYAA
----- END CREV PROOF -----

----- BEGIN CREV PROOF -----
kind: package review
version: -1
date: "2021-09-23T13:31:15.528155882+09:00"
from:
  id-type: crev
  id: _-m0udEIcN1HxdvL29x_4qHAmCyrb1lxk-R6s2__2D0
  url: "https://github.com/yvt/crev-proofs"
package:
  source: "https://crates.io"
  name: hakuna
  version: 0.0.1
  revision: 5ba46771805bbe975bfe4cc2db6f6e404b482a4a
  digest: OHC4I61F1yQIH7a3vddnJsbBY5gEam1DjkpLnTzyhgo
review:
  thoroughness: medium
  understanding: medium
  rating: negative
comment: |-
  This crate doesn't seem to do anything useful, and its intent is unclear, but
  probably it's for name-squatting or making a point about the lack of
  name-squatting policy. The author released a series of crates with similar
  contents. See my review on metaverse 0.0.1 for the list.
  
  This crate is harmless.
----- SIGN CREV PROOF -----
Na8TPXldJWtFDN7s2PtDznSCS8nTHczN4-gNtHi5BbaTq8Mm-5XmLvimQW05H4e3bbgAtU9NvsbTDBtBmh4WCQ
----- END CREV PROOF -----

----- BEGIN CREV PROOF -----
kind: package review
version: -1
date: "2021-09-23T13:32:38.248260934+09:00"
from:
  id-type: crev
  id: _-m0udEIcN1HxdvL29x_4qHAmCyrb1lxk-R6s2__2D0
  url: "https://github.com/yvt/crev-proofs"
package:
  source: "https://crates.io"
  name: matata
  version: 0.0.1
  revision: 886414c69bcdae1b2eaa30d2267ed1e908c1585a
  digest: Zj9hGaQo_95vnqRQ9TJsFPzOcV0enMNeW7X0Mq9KcMk
review:
  thoroughness: medium
  understanding: medium
  rating: negative
comment: |-
  This crate doesn't seem to do anything useful, and its intent is unclear, but
  probably it's for name-squatting or making a point about the lack of
  name-squatting policy. The author released a series of crates with similar
  contents. See my review on metaverse 0.0.1 for the list.
  
  This crate is harmless.
----- SIGN CREV PROOF -----
T7BKQqWP9BREtp_U5PHRxVVxTmuMwg0EbTDLr2pSDI_o5gwYHajSwn7WGl8qIyX3y64QsnEPg97SkMpgHI3RCw
----- END CREV PROOF -----

----- BEGIN CREV PROOF -----
kind: package review
version: -1
date: "2021-09-23T13:33:08.561774576+09:00"
from:
  id-type: crev
  id: _-m0udEIcN1HxdvL29x_4qHAmCyrb1lxk-R6s2__2D0
  url: "https://github.com/yvt/crev-proofs"
package:
  source: "https://crates.io"
  name: loquat
  version: 0.0.1
  revision: 0e6a7fdba9f05decca94f4b954d1b2331562ee4d
  digest: goDdC9CfC1qqKaKTcLljCtsj-yR3qWa78qTGjS1gIew
review:
  thoroughness: medium
  understanding: medium
  rating: negative
comment: |-
  This crate doesn't seem to do anything useful, and its intent is unclear, but
  probably it's for name-squatting or making a point about the lack of
  name-squatting policy. The author released a series of crates with similar
  contents. See my review on metaverse 0.0.1 for the list.
  
  This crate is not actively malicious. The description is misleading.
----- SIGN CREV PROOF -----
5DfnKGczM8usi6WCxue7KXJK0LfFRPL1ffSdw8hm_O-XPHJL7K1K4OooQN8nD6K2mSGLirTgzD_Z_SfhO2_9BQ
----- END CREV PROOF -----

----- BEGIN CREV PROOF -----
kind: package review
version: -1
date: "2021-09-23T13:35:39.850919257+09:00"
from:
  id-type: crev
  id: _-m0udEIcN1HxdvL29x_4qHAmCyrb1lxk-R6s2__2D0
  url: "https://github.com/yvt/crev-proofs"
package:
  source: "https://crates.io"
  name: gothic
  version: 0.0.1
  revision: cdeee893da081fd834daa578eea1cc29e9958549
  digest: 0iID8H2U_X_E9irmDOFUI6RBnkcQb5G03e22gaTWskk
review:
  thoroughness: medium
  understanding: medium
  rating: negative
comment: |-
  This crate doesn't seem to do anything useful, and its intent is unclear, but
  probably it's for name-squatting or making a point about the lack of
  name-squatting policy. The author released a series of crates with similar
  contents. See my review on metaverse 0.0.1 for the list.
  
  This crate is not actively malicious. The description is misleading.
----- SIGN CREV PROOF -----
lEtze1CgH1o5eNtImYG3LE0UKEFkzFm_PBiBIkWSpOrMR9dqvPF4IWGO2Q42mrNVq4xZYWX-cXuwgB0Td8fNCw
----- END CREV PROOF -----

----- BEGIN CREV PROOF -----
kind: package review
version: -1
date: "2021-09-23T13:36:13.498481937+09:00"
from:
  id-type: crev
  id: _-m0udEIcN1HxdvL29x_4qHAmCyrb1lxk-R6s2__2D0
  url: "https://github.com/yvt/crev-proofs"
package:
  source: "https://crates.io"
  name: lemon
  version: 0.0.1
  revision: e815f174bdc0ed8067371e7bea56d71ce08af363
  digest: PnNGbbz7VvCLSPljw2d64yRuiBTBDp3yHe1rNFbTkWA
review:
  thoroughness: medium
  understanding: medium
  rating: negative
comment: |-
  This crate doesn't seem to do anything useful, and its intent is unclear, but
  probably it's for name-squatting or making a point about the lack of
  name-squatting policy. The author released a series of crates with similar
  contents. See my review on metaverse 0.0.1 for a list of such crates.
  
  This crate is not actively malicious. The description is misleading.
----- SIGN CREV PROOF -----
XPK9Evd27HBkTgrPUCM7V7tQ20bbwJfgaYHTD538TtXk2nAHtuYGWXijnnj-jo_94VqyCPm68Myr_odrSn1iDw
----- END CREV PROOF -----

